import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { vi, describe, it, expect } from "vitest";
import { mockL10n, simulateUserInput } from "../fixtures/testUtils";
import { generateValidUser, generateInvalidEmails, validationMessages } from "../fixtures/testData";
import { generateEdgeCaseStrings } from "../fixtures/advancedGenerators";
import Form from "../../Form";
import FormInput from "../../FormInput";
import { z } from "zod";

// Mock setup following the new testing instructions
mockL10n();

const TestFormSchema = z.object({
  email: z.string().email("validation.errors.invalid_email"),
  name: z.string().min(1, "validation.errors.field_empty"),
});

describe("Form Component - Email Validation with Faker.js", () => {
  it("should accept valid emails generated by Faker", async () => {
    // Arrange - Using Faker.js generated data
    const validUser = generateValidUser();
    
    // Act
    render(
      <Form
        schema={TestFormSchema}
        initialValues={{ email: "", name: "" }}
        onSubmit={vi.fn()}
      >
        <FormInput name="email" label="Email" type="email" />
        <FormInput name="name" label="Name" type="text" />
        <button type="submit">Submit</button>
      </Form>
    );
    
    const emailInput = screen.getByLabelText(/email/i);
    simulateUserInput(emailInput, validUser.email);
    
    // Assert
    await waitFor(() => {
      expect(screen.queryByText(validationMessages.email.invalid))
        .not.toBeInTheDocument();
    });
  });

  it("should reject invalid emails with proper error messages", async () => {
    // Arrange - Using generated invalid emails
    const invalidEmails = generateInvalidEmails();
    const firstInvalidEmail = invalidEmails[0];
    
    // Act
    render(
      <Form
        schema={TestFormSchema}
        initialValues={{ email: "", name: "" }}
        onSubmit={vi.fn()}
      >
        <FormInput name="email" label="Email" type="email" />
        <FormInput name="name" label="Name" type="text" />
        <button type="submit">Submit</button>
      </Form>
    );
    
    const emailInput = screen.getByLabelText(/email/i);
    simulateUserInput(emailInput, firstInvalidEmail);
    
    // Assert
    await waitFor(() => {
      expect(screen.getByText(validationMessages.email.invalid))
        .toBeInTheDocument();
    });
  });

  it("should handle edge case strings properly", async () => {
    // Arrange - Using edge case generators
    const edgeCases = generateEdgeCaseStrings();
    const emptyString = edgeCases[0]; // First one is empty string
    
    // Act
    render(
      <Form
        schema={TestFormSchema}
        initialValues={{ email: "", name: "" }}
        onSubmit={vi.fn()}
      >
        <FormInput name="email" label="Email" type="email" />
        <FormInput name="name" label="Name" type="text" />
        <button type="submit">Submit</button>
      </Form>
    );
    
    const nameInput = screen.getByLabelText(/name/i);
    simulateUserInput(nameInput, emptyString);
    
    // Assert
    await waitFor(() => {
      expect(screen.getByText(validationMessages.required.empty))
        .toBeInTheDocument();
    });
  });

  it("should submit form successfully with valid generated data", async () => {
    // Arrange
    const validUser = generateValidUser();
    const mockSubmit = vi.fn();
    
    // Act
    render(
      <Form
        schema={TestFormSchema}
        initialValues={{ email: "", name: "" }}
        onSubmit={mockSubmit}
      >
        <FormInput name="email" label="Email" type="email" />
        <FormInput name="name" label="Name" type="text" />
        <button type="submit">Submit</button>
      </Form>
    );
    
    simulateUserInput(screen.getByLabelText(/email/i), validUser.email);
    simulateUserInput(screen.getByLabelText(/name/i), validUser.name);
    
    fireEvent.click(screen.getByRole("button", { name: /submit/i }));
    
    // Assert
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith({
        email: validUser.email,
        name: validUser.name,
      });
    });
  });
});
